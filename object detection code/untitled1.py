# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rAzbonmkVofcvXsDefXqPPNfkgWe3mHp
"""

!git clone 'https://github.com/noobmaster69-max/Retail.git'

# Commented out IPython magic to ensure Python compatibility.
#!git clone 'https://github.com/Shenggan/BCCD_Dataset.git'
#convert xml file to csv file
import os, sys, random, shutil
import xml.etree.ElementTree as ET
from glob import glob
import pandas as pd
from shutil import copyfile
import pandas as pd
from sklearn import preprocessing, model_selection
import matplotlib.pyplot as plt
# %matplotlib inline
from matplotlib import patches
import numpy as np
import cv2
import PIL
from PIL import Image

annotations = sorted(glob('/content/Retail/Dataset/Annotations/*.xml'))
df = []
cnt = 0
path = "/content/Retail/Dataset/Images/"


for file in annotations:
  # -1 count from behind from annotations , split with /,split with .[0]
  # take from front
   prev_filename = file.split('/')[-1].split('.')[0] + '.jpg'
   filename = str(cnt)+'jpg'
   row = []
   image = cv2.imread(path+prev_filename)
   img_height, img_width,_ = image.shape
   
   
   parsedXML = ET.parse(file)
   for node in parsedXML.getroot().iter('object'):
     bloodcells = node.find('name').text
     xmin = int(node.find('bndbox/xmin').text)
     xmax = int(node.find('bndbox/xmax').text)
     ymin = int(node.find('bndbox/ymin').text)
     ymax = int(node.find('bndbox/ymax').text)
     row = [prev_filename, filename, bloodcells, xmin, xmax, ymin, ymax, img_width, img_height]
     df.append(row)
   cnt = cnt+1
  
data = pd.DataFrame(df, columns=['prev_filename', 'filename', 'cell_type', 'xmin', 'xmax', 'ymin', 'ymax','img_width','img_height'])
data[['prev_filename', 'filename', 'cell_type', 'xmin', 'xmax', 'ymin', 'ymax', 'img_width','img_height']].to_csv('/content/fruit_detection.csv', index=False)
data.head(10)

#convert data to yolo v5 compatible format
#filename , cell_type, xmin, xmax, ymin, ymax, labels, width, height, xcenter, ycenter, 
# xcenter norm, ycenter_norm, width norm and height norm
def width(df):
  return int(df.xmax - df.xmin)

def height(df):
  return int(df.ymax - df.ymin)

def x_center(df):
  return int(df.xmin + (df.width/2))

def y_center(df):
  return int(df.ymin + (df.height/2))

def w_norm(df):
  return df/(df.img_width)

def h_norm(df):
  return df/(df.img_height)

df = pd.read_csv('/content/fruit_detection.csv')

le = preprocessing.LabelEncoder()
labels = le.fit(df['cell_type'])
print(le.classes_)
labels = le.transform(df['cell_type'])
df['labels'] = labels

df['width'] = df.apply(width, axis=1)
df['height'] = df.apply(height, axis =1)

df['x_center'] = df.apply(x_center, axis =1)
df['y_center'] = df.apply(y_center, axis =1)
count =0
x=0
y=0
w=0
z=0
x_centernorm = []
y_centernorm = []
widthnorm =[]
heightnorm = []
for _,row in df.iterrows():
  x = row.x_center/row.img_width 
  y = row.width/row.img_width
  w = row.y_center/row.img_height
  z = row.height/row.img_height
  x_centernorm.append(x)
  widthnorm.append(y)
  y_centernorm.append(w)
  heightnorm.append(z)
  count=count+1
print(count)
print(len(y_centernorm))

df['x_center_norm'] = x_centernorm
df['width_norm'] = widthnorm
df['y_center_norm'] = y_centernorm
df['height_norm'] = heightnorm
df.head(200)
# df['x_center_norm'] = df['x_center'].apply(w_norm)
# df['width_norm'] = df['width'].apply(w_norm)

# df['y_center_norm'] = df['y_center'].apply(h_norm)
# df['height_norm'] = df['height'].apply(h_norm)

df_train, df_valid = model_selection.train_test_split(df, test_size=0.2, random_state=42, shuffle=True)
print(df_train.shape, df_valid.shape)

#create directory in system
os.mkdir('/content/products/')
os.mkdir('/content/products/images/')
os.mkdir('/content/products/images/train/')
os.mkdir('/content/products/images/valid/')

os.mkdir('/content/products/labels/')
os.mkdir('/content/products/labels/train/')
os.mkdir('/content/products/labels/valid/')

def segregate_data(df, img_path, label_path, train_img_path, train_label_path):
  filenames = []
  for filename in df.filename:
    filenames.append(filename)

  #create set for filenames
  filenames = set(filenames)

  for filename in df.filename:
    yolo_list =[]

    for _,row in df[df.filename == filename].iterrows():
      yolo_list.append([row.labels, row.x_center_norm, row.y_center_norm, row.width_norm, row.height_norm])
  
    yolo_list = np.array(yolo_list)
    txt_filename = os.path.join(train_label_path, str(row.prev_filename.split('.')[0]) + '.txt')

    #save .img and .txt file 
    np.savetxt(txt_filename, yolo_list, fmt=["%d", "%f", "%f", "%f", "%f"])
    shutil.copyfile(os.path.join(img_path,row.prev_filename), os.path.join(train_img_path,row.prev_filename))

## Apply function ## 
src_img_path = "/content/Retail/Dataset/Images/"
src_label_path = "/content/Retail/Dataset/Annotations/"

train_img_path = "/content/products/images/train"
train_label_path = "/content/products/labels/train"

valid_img_path = "/content/products/images/valid"
valid_label_path = "/content/products/labels/valid"

segregate_data(df_train, src_img_path, src_label_path, train_img_path, train_label_path)
segregate_data(df_valid, src_img_path, src_label_path, valid_img_path, valid_label_path)

print("No. of Training images", len(os.listdir('/content/products/images/train')))
print("No. of Training labels", len(os.listdir('/content/products/labels/train')))

print("No. of valid images", len(os.listdir('/content/products/images/valid')))
print("No. of valid labels", len(os.listdir('/content/products/labels/valid')))

!git clone  'https://github.com/ultralytics/yolov5.git'
!pip install -qr '/content/yolov5/requirements.txt'
#create a yaml file and copy it into yolov5 folder

shutil.copyfile('/content/product.yaml','/content/yolov5/product.yaml')

# Commented out IPython magic to ensure Python compatibility.
#model training
#Training Parameters
# !python
# - <'location of train.py file'>
# - --img <'width of image'>
# - --batch <'batch size'>
# - --epochs <'no of epochs'>
# - --data <'location of the .yaml file'>
# - --cfg <'Which yolo configuration you want'>(yolov5s/yolov5m/yolov5l/yolov5x).yaml | (small, medium, large, xlarge)
# - --name <'Name of the best model to save after training'>

# Start tensorboard (optional)
# %load_ext tensorboard
# %tensorboard --logdir runs/

!python yolov5/train.py --img 640 --batch 16 --epochs 500 \
    --data product.yaml --cfg /content/yolov5/models/yolov5s.yaml --name products

# Commented out IPython magic to ensure Python compatibility.
import os, sys, random
from glob import glob
import matplotlib.pyplot as plt
# %matplotlib inline
#!pip install -qr '/content/drive/My Drive/yolo/requirements.txt'  # install dependencies

## Add the path where you have stored the neccessary supporting files to run detect.py ##
## Replace this with your path.##
#sys.path.insert(0, '/content/drive/My Drive/Machine Learning Projects/YOLO/SOURCE/') 
#print(sys.path)
#cwd = os.getcwd()
#print(cwd)

## Single Image prediction
## Beware the contents in the output folder will be deleted for every prediction
output = !python '/content/yolov5/detect.py' --source '/content/Retail/Dataset/Images/mixed_24.jpg'  --weights '/content/runs/train/products/weights/best.pt' --project '/content/OUTPUTS/' --device 'cpu'
print(output)
#img = plt.imread('/content/OUTPUTS/apple_1.jpg')
#plt.imshow(img)